name: Deploy Strapi to ECS with CodeDeploy

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - monitor
          - rollback
      deployment_id:
        description: 'CodeDeploy Deployment ID (for monitor/rollback actions)'
        required: false
        type: string

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: strapi-app-tohid
  ECR_REGISTRY: 607700977843.dkr.ecr.us-east-2.amazonaws.com
  ECS_CLUSTER: tohid-task12-cluster
  ECS_SERVICE: tohid-task12-service
  CODEPLOY_APP: tohid-task12-codedeploy-app
  CODEPLOY_DEPLOYMENT_GROUP: tohid-task12-deployment-group

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || inputs.action == 'deploy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Docker image
        id: build-image
        run: |
          IMAGE_TAG=${{ github.sha }}
          docker build -t $ECR_REPOSITORY:$IMAGE_TAG ./strapi-app
          docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image_url=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: terraform init
        working-directory: terraform9_task12

      - name: Terraform Apply
        run: terraform apply -auto-approve -var="ecr_image_url=${{ steps.build-image.outputs.image_url }}"
        working-directory: terraform9_task12
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Wait for RDS Instance to be Available
        run: |
          echo "Waiting for RDS instance to be available..."
          MAX_WAIT_TIME=900  # 15 minutes
          WAIT_TIME=0
          SLEEP_INTERVAL=30
          
          # Get the security group ID for our RDS security group
          RDS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=tohid-task12-rds-sg" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
          
          if [ -z "$RDS_SG_ID" ] || [ "$RDS_SG_ID" = "None" ]; then
            echo "RDS security group not found. Listing all security groups:"
            aws ec2 describe-security-groups --query 'SecurityGroups[].{Name:GroupName,ID:GroupId}' --output table
            exit 1
          fi
          
          echo "Found RDS security group: $RDS_SG_ID"
          
          # Get the RDS instance identifier by searching for instances associated with our security group
          RDS_INSTANCE_ID=$(aws rds describe-db-instances --query "DBInstances[?contains(VpcSecurityGroups[0].VpcSecurityGroupId, '$RDS_SG_ID')].DBInstanceIdentifier" --output text 2>/dev/null | head -1)
          
          if [ -z "$RDS_INSTANCE_ID" ] || [ "$RDS_INSTANCE_ID" = "None" ]; then
            echo "No RDS instance found associated with security group $RDS_SG_ID"
            echo "Listing all RDS instances:"
            aws rds describe-db-instances --query 'DBInstances[].{Identifier:DBInstanceIdentifier,Status:DBInstanceStatus,SecurityGroups:VpcSecurityGroups[0].VpcSecurityGroupId}' --output table
            echo "Trying to find any RDS instance..."
            RDS_INSTANCE_ID=$(aws rds describe-db-instances --query 'DBInstances[0].DBInstanceIdentifier' --output text 2>/dev/null || echo "")
          fi
          
          if [ -z "$RDS_INSTANCE_ID" ] || [ "$RDS_INSTANCE_ID" = "None" ]; then
            echo "No RDS instances found at all. Skipping RDS wait."
            exit 0
          fi
          
          echo "Found RDS instance: $RDS_INSTANCE_ID"
          
          while [ $WAIT_TIME -lt $MAX_WAIT_TIME ]; do
            RDS_STATUS=$(aws rds describe-db-instances --db-instance-identifier $RDS_INSTANCE_ID --query 'DBInstances[0].DBInstanceStatus' --output text 2>/dev/null || echo "NOT_FOUND")
            
            echo "RDS Status: $RDS_STATUS (waited ${WAIT_TIME}s)"
            
            if [ "$RDS_STATUS" = "available" ]; then
              echo "RDS instance is available!"
              break
            elif [ "$RDS_STATUS" = "deleting" ] || [ "$RDS_STATUS" = "deleted" ]; then
              echo "RDS instance is being deleted or deleted"
              exit 1
            fi
            
            sleep $SLEEP_INTERVAL
            WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
          done
          
          if [ $WAIT_TIME -ge $MAX_WAIT_TIME ]; then
            echo "Timeout waiting for RDS instance to be available"
            exit 1
          fi

      - name: Wait for ALB to be Active
        run: |
          echo "Waiting for ALB to be active..."
          MAX_WAIT_TIME=600  # 10 minutes
          WAIT_TIME=0
          SLEEP_INTERVAL=30
          
          while [ $WAIT_TIME -lt $MAX_WAIT_TIME ]; do
            ALB_STATE=$(aws elbv2 describe-load-balancers --names tohid-task12-alb --query 'LoadBalancers[0].State.Code' --output text 2>/dev/null || echo "NOT_FOUND")
            
            echo "ALB State: $ALB_STATE (waited ${WAIT_TIME}s)"
            
            if [ "$ALB_STATE" = "active" ]; then
              echo "ALB is active!"
              break
            elif [ "$ALB_STATE" = "failed" ]; then
              echo "ALB creation failed"
              exit 1
            fi
            
            sleep $SLEEP_INTERVAL
            WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
          done
          
          if [ $WAIT_TIME -ge $MAX_WAIT_TIME ]; then
            echo "Timeout waiting for ALB to be active"
            exit 1
          fi

      - name: Wait for ECS Service to be Ready
        run: |
          echo "Waiting for ECS service to be ready..."
          MAX_WAIT_TIME=600  # 10 minutes
          WAIT_TIME=0
          SLEEP_INTERVAL=30
          
          while [ $WAIT_TIME -lt $MAX_WAIT_TIME ]; do
            SERVICE_STATUS=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].status' --output text)
            RUNNING_COUNT=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].runningCount' --output text)
            DESIRED_COUNT=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].desiredCount' --output text)
            
            echo "Service Status: $SERVICE_STATUS, Running: $RUNNING_COUNT/$DESIRED_COUNT (waited ${WAIT_TIME}s)"
            
            if [ "$SERVICE_STATUS" = "ACTIVE" ] && [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ] && [ "$RUNNING_COUNT" -gt 0 ]; then
              echo "ECS service is ready!"
              break
            fi
            
            sleep $SLEEP_INTERVAL
            WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
          done
          
          if [ $WAIT_TIME -ge $MAX_WAIT_TIME ]; then
            echo "Timeout waiting for ECS service to be ready"
            exit 1
          fi

      - name: Wait for ALB Target Group Health
        run: |
          echo "Waiting for ALB target group to be healthy..."
          MAX_WAIT_TIME=600  # 10 minutes
          WAIT_TIME=0
          SLEEP_INTERVAL=30
          
          # Get target group ARN
          TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups --names tohid-task12-blue-tg --query 'TargetGroups[0].TargetGroupArn' --output text)
          
          while [ $WAIT_TIME -lt $MAX_WAIT_TIME ]; do
            HEALTHY_COUNT=$(aws elbv2 describe-target-health --target-group-arn $TARGET_GROUP_ARN --query 'length(TargetHealthDescriptions[?TargetHealth.State==`healthy`])' --output text)
            TOTAL_COUNT=$(aws elbv2 describe-target-health --target-group-arn $TARGET_GROUP_ARN --query 'length(TargetHealthDescriptions)' --output text)
            
            echo "Healthy targets: $HEALTHY_COUNT/$TOTAL_COUNT (waited ${WAIT_TIME}s)"
            
            if [ "$HEALTHY_COUNT" -gt 0 ] && [ "$HEALTHY_COUNT" -eq "$TOTAL_COUNT" ]; then
              echo "Target group is healthy!"
              break
            fi
            
            sleep $SLEEP_INTERVAL
            WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
          done
          
          if [ $WAIT_TIME -ge $MAX_WAIT_TIME ]; then
            echo "Timeout waiting for target group to be healthy"
            exit 1
          fi

      - name: Update ECS Task Definition
        id: update-task-def
        run: |
          # Get current task definition
          TASK_DEF_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].taskDefinition' --output text)
          
          # Get task definition details and filter out metadata fields
          TASK_DEF=$(aws ecs describe-task-definition --task-definition $TASK_DEF_ARN --query 'taskDefinition' --output json)
          
          # Create a clean task definition for registration (remove metadata fields and handle null tags)
          CLEAN_TASK_DEF=$(echo $TASK_DEF | jq '{
            family: .family,
            taskRoleArn: .taskRoleArn,
            executionRoleArn: .executionRoleArn,
            networkMode: .networkMode,
            containerDefinitions: .containerDefinitions,
            volumes: .volumes,
            placementConstraints: .placementConstraints,
            requiresCompatibilities: .requiresCompatibilities,
            cpu: .cpu,
            memory: .memory
          } + (if .tags then {tags: .tags} else {} end)')
          
          # Update container image
          UPDATED_TASK_DEF=$(echo $CLEAN_TASK_DEF | jq --arg IMAGE_URL "${{ steps.build-image.outputs.image_url }}" '.containerDefinitions[0].image = $IMAGE_URL')
          
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json "$UPDATED_TASK_DEF" --query 'taskDefinition.taskDefinitionArn' --output text)
          
          echo "new_task_def_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "Updated task definition: $NEW_TASK_DEF_ARN"

      - name: Create CodeDeploy Deployment
        id: codedeploy
        run: |
          # Create appspec.json for CodeDeploy
          cat > appspec.json << EOF
          {
            "version": 0.0,
            "Resources": [
              {
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": "${{ steps.update-task-def.outputs.new_task_def_arn }}",
                    "LoadBalancerInfo": {
                      "ContainerName": "strapi",
                      "ContainerPort": 1337
                    }
                  }
                }
              }
            ]
          }
          EOF
          
          # Create deployment using properly structured revision file
          jq -n --arg content "$(cat appspec.json | jq -c .)" '{"content": $content}' > revision.json
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name $CODEPLOY_APP \
            --deployment-group-name $CODEPLOY_DEPLOYMENT_GROUP \
            --revision file://revision.json)
          
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "Created deployment: $DEPLOYMENT_ID"

      - name: Wait for CodeDeploy Deployment to Start
        run: |
          DEPLOYMENT_ID="${{ steps.codedeploy.outputs.deployment_id }}"
          MAX_WAIT_TIME=300  # 5 minutes
          WAIT_TIME=0
          SLEEP_INTERVAL=10
          
          echo "Waiting for CodeDeploy deployment to start..."
          
          while [ $WAIT_TIME -lt $MAX_WAIT_TIME ]; do
            STATUS=$(aws deploy get-deployment --deployment-id $DEPLOYMENT_ID --query 'deploymentInfo.status' --output text)
            
            echo "Deployment status: $STATUS (waited ${WAIT_TIME}s)"
            
            if [ "$STATUS" = "InProgress" ] || [ "$STATUS" = "Ready" ]; then
              echo "CodeDeploy deployment has started!"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Stopped" ]; then
              echo "CodeDeploy deployment failed to start: $STATUS"
              exit 1
            fi
            
            sleep $SLEEP_INTERVAL
            WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
          done
          
          if [ $WAIT_TIME -ge $MAX_WAIT_TIME ]; then
            echo "Timeout waiting for CodeDeploy deployment to start"
            exit 1
          fi

      - name: Monitor Deployment Status
        id: monitor
        run: |
          DEPLOYMENT_ID="${{ steps.codedeploy.outputs.deployment_id }}"
          MAX_WAIT_TIME=1800  # 30 minutes
          WAIT_TIME=0
          SLEEP_INTERVAL=30
          
          echo "Monitoring deployment: $DEPLOYMENT_ID"
          
          while [ $WAIT_TIME -lt $MAX_WAIT_TIME ]; do
            STATUS=$(aws deploy get-deployment --deployment-id $DEPLOYMENT_ID --query 'deploymentInfo.status' --output text)
            
            echo "Deployment status: $STATUS (waited ${WAIT_TIME}s)"
            
            case $STATUS in
              "Succeeded")
                echo "Deployment succeeded!"
                echo "status=success" >> $GITHUB_OUTPUT
                exit 0
                ;;
              "Failed"|"Stopped")
                echo "Deployment failed with status: $STATUS"
                echo "status=failed" >> $GITHUB_OUTPUT
                exit 1
                ;;
              "InProgress"|"Ready")
                sleep $SLEEP_INTERVAL
                WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
                ;;
              *)
                echo "Unknown status: $STATUS"
                sleep $SLEEP_INTERVAL
                WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
                ;;
            esac
          done
          
          echo "Deployment monitoring timed out"
          echo "status=timeout" >> $GITHUB_OUTPUT
          exit 1

      - name: Rollback on Failure
        if: steps.monitor.outputs.status == 'failed' || steps.monitor.outputs.status == 'timeout'
        run: |
          echo "Deployment failed, initiating rollback..."
          
          # Get the previous task definition
          PREV_TASK_DEF_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].taskDefinition' --output text)
          
          # Create rollback deployment
          cat > rollback-appspec.json << EOF
          {
            "version": 0.0,
            "Resources": [
              {
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": "$PREV_TASK_DEF_ARN",
                    "LoadBalancerInfo": {
                      "ContainerName": "strapi",
                      "ContainerPort": 1337
                    }
                  }
                }
              }
            ]
          }
          EOF
          
          # Create rollback deployment
          ROLLBACK_DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name $CODEPLOY_APP \
            --deployment-group-name $CODEPLOY_DEPLOYMENT_GROUP \
            --revision revisionType=AppSpecContent,appSpecContent='{"content": "'$(cat rollback-appspec.json | jq -c .)'"}')
          
          echo "Rollback deployment created: $ROLLBACK_DEPLOYMENT_ID"
          
          # Wait for rollback to complete
          aws deploy wait deployment-successful --deployment-id $ROLLBACK_DEPLOYMENT_ID
          
          echo "Rollback completed successfully"

      - name: Deployment Summary
        run: |
          if [ "${{ steps.monitor.outputs.status }}" == "success" ]; then
            echo "✅ Deployment completed successfully!"
            echo "Image: ${{ steps.build-image.outputs.image_url }}"
            echo "Task Definition: ${{ steps.update-task-def.outputs.new_task_def_arn }}"
            echo "Deployment ID: ${{ steps.codedeploy.outputs.deployment_id }}"
          else
            echo "❌ Deployment failed or timed out"
            echo "Status: ${{ steps.monitor.outputs.status }}"
            exit 1
          fi

  monitor:
    runs-on: ubuntu-latest
    if: inputs.action == 'monitor'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check Deployment Status
        id: check-status
        run: |
          DEPLOYMENT_ID="${{ inputs.deployment_id }}"
          
          # Get deployment status
          STATUS=$(aws deploy get-deployment --deployment-id $DEPLOYMENT_ID --query 'deploymentInfo.status' --output text)
          CREATED=$(aws deploy get-deployment --deployment-id $DEPLOYMENT_ID --query 'deploymentInfo.createTime' --output text)
          COMPLETED=$(aws deploy get-deployment --deployment-id $DEPLOYMENT_ID --query 'deploymentInfo.completeTime' --output text)
          
          echo "Deployment ID: $DEPLOYMENT_ID"
          echo "Status: $STATUS"
          echo "Created: $CREATED"
          echo "Completed: $COMPLETED"
          
          # Get deployment details
          aws deploy get-deployment --deployment-id $DEPLOYMENT_ID --query 'deploymentInfo' --output table
          
          # Check ECS service status
          echo "ECS Service Status:"
          aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,PendingCount:pendingCount}' --output table
          
          # Check recent events
          echo "Recent ECS Events:"
          aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].events[:5]' --output table

      - name: Check CloudWatch Alarms
        run: |
          echo "Checking CloudWatch Alarms:"
          
          # List alarms with task12 in the name
          aws cloudwatch describe-alarms --alarm-name-prefix "strapi-task12" --query 'MetricAlarms[].{Name:AlarmName,State:StateValue,Description:AlarmDescription}' --output table
          
          # Check if any alarms are in ALARM state
          ALARM_COUNT=$(aws cloudwatch describe-alarms --alarm-name-prefix "strapi-task12" --state-value ALARM --query 'length(MetricAlarms)' --output text)
          
          if [ "$ALARM_COUNT" -gt 0 ]; then
            echo "⚠️  $ALARM_COUNT alarms are in ALARM state!"
            aws cloudwatch describe-alarms --alarm-name-prefix "strapi-task12" --state-value ALARM --query 'MetricAlarms[].AlarmName' --output text
          else
            echo "✅ No alarms in ALARM state"
          fi

      - name: Check Application Health
        run: |
          echo "Checking application health endpoints:"
          
          # Get ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers --names tohid-task12-alb --query 'LoadBalancers[0].DNSName' --output text)
          
          if [ "$ALB_DNS" != "None" ]; then
            echo "ALB DNS: $ALB_DNS"
            
            # Test health check endpoint
            echo "Testing health check endpoint..."
            curl -f -s -o /dev/null -w "HTTP Status: %{http_code}, Response Time: %{time_total}s\n" http://$ALB_DNS/ || echo "Health check failed"
            
            # Test admin endpoint
            echo "Testing admin endpoint..."
            curl -f -s -o /dev/null -w "HTTP Status: %{http_code}, Response Time: %{time_total}s\n" http://$ALB_DNS/admin || echo "Admin endpoint failed"
          else
            echo "ALB not found"
          fi

  rollback:
    runs-on: ubuntu-latest
    if: inputs.action == 'rollback'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback Deployment
        id: rollback
        run: |
          echo "Initiating rollback for deployment: ${{ inputs.deployment_id }}"
          
          # Get the current task definition
          CURRENT_TASK_DEF_ARN=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].taskDefinition' --output text)
          
          # Get the previous task definition (assuming it's the one before current)
          TASK_DEF_FAMILY=$(echo $CURRENT_TASK_DEF_ARN | cut -d'/' -f2 | cut -d':' -f1)
          TASK_DEF_REVISION=$(echo $CURRENT_TASK_DEF_ARN | cut -d':' -f2)
          PREV_REVISION=$((TASK_DEF_REVISION - 1))
          PREV_TASK_DEF_ARN="$TASK_DEF_FAMILY:$PREV_REVISION"
          
          echo "Current Task Definition: $CURRENT_TASK_DEF_ARN"
          echo "Rollback Task Definition: $PREV_TASK_DEF_ARN"
          
          # Create rollback appspec
          cat > rollback-appspec.json << EOF
          {
            "version": 0.0,
            "Resources": [
              {
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": "$PREV_TASK_DEF_ARN",
                    "LoadBalancerInfo": {
                      "ContainerName": "strapi",
                      "ContainerPort": 1337
                    }
                  }
                }
              }
            ]
          }
          EOF
          
          # Create rollback deployment
          ROLLBACK_DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name $CODEPLOY_APP \
            --deployment-group-name $CODEPLOY_DEPLOYMENT_GROUP \
            --revision revisionType=AppSpecContent,appSpecContent='{"content": "'$(cat rollback-appspec.json | jq -c .)'"}')
          
          echo "Rollback deployment created: $ROLLBACK_DEPLOYMENT_ID"
          echo "rollback_deployment_id=$ROLLBACK_DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Monitor Rollback
        run: |
          ROLLBACK_DEPLOYMENT_ID="${{ steps.rollback.outputs.rollback_deployment_id }}"
          MAX_WAIT_TIME=900  # 15 minutes
          WAIT_TIME=0
          SLEEP_INTERVAL=30
          
          echo "Monitoring rollback deployment: $ROLLBACK_DEPLOYMENT_ID"
          
          while [ $WAIT_TIME -lt $MAX_WAIT_TIME ]; do
            STATUS=$(aws deploy get-deployment --deployment-id $ROLLBACK_DEPLOYMENT_ID --query 'deploymentInfo.status' --output text)
            
            echo "Rollback status: $STATUS (waited ${WAIT_TIME}s)"
            
            case $STATUS in
              "Succeeded")
                echo "Rollback succeeded!"
                exit 0
                ;;
              "Failed"|"Stopped")
                echo "Rollback failed with status: $STATUS"
                exit 1
                ;;
              "InProgress"|"Ready")
                sleep $SLEEP_INTERVAL
                WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
                ;;
              *)
                echo "Unknown status: $STATUS"
                sleep $SLEEP_INTERVAL
                WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
                ;;
            esac
          done
          
          echo "Rollback monitoring timed out"
          exit 1 